warning: in the working copy of 'src/app/app.module.ts', LF will be replaced by CRLF the next time Git touches it
[1mdiff --git a/src/app/app.module.ts b/src/app/app.module.ts[m
[1mindex 89759d9..822aa8e 100644[m
[1m--- a/src/app/app.module.ts[m
[1m+++ b/src/app/app.module.ts[m
[36m@@ -4,6 +4,8 @@[m [mimport { ConfigModule } from '@nestjs/config';[m
 import { TypeOrmModule } from '@nestjs/typeorm';[m
 [m
 import { WalletModule } from '../wallet/wallet.module';[m
[32m+[m[32mimport { ProfileModule } from '../profile/profile.module'; // âœ… ADDED[m
[32m+[m
 import { AuthModule } from '../modules/auth/auth.module';[m
 import { UsersModule } from '../modules/users/users.module';[m
 import { StoreItemsModule } from '../modules/store-items/store-items.module';[m
[36m@@ -29,15 +31,16 @@[m [mimport { IdentityModule } from '../identity/identity.module';[m
 [m
     // Core modules[m
     UsersModule,[m
[31m-    AuthModule,       // âœ… enables /auth/login and registers jwt strategy[m
[32m+[m[32m    AuthModule,        // âœ… enables /auth/login and registers jwt strategy[m
     WalletModule,[m
[31m-    StoreItemsModule, // âœ… enables /store-items/*[m
[32m+[m[32m    StoreItemsModule,  // âœ… enables /store-items/*[m
[32m+[m[32m    ProfileModule,     // âœ… ENABLES profiles table + DI[m
 [m
[31m-    // âœ… ADD[m
[32m+[m[32m    // Identity[m
     IdentityModule,[m
 [m
     // Dev tools[m
[31m-    DevSeedModule,    // âœ… enables /dev-seed/*[m
[32m+[m[32m    DevSeedModule,     // âœ… enables /dev-seed/*[m
   ],[m
 })[m
 export class AppModule {}[m
[1mdiff --git a/src/modules/staff/staff.entity.ts b/src/modules/staff/staff.entity.ts[m
[1mindex 16e436b..c9e0cc6 100644[m
[1m--- a/src/modules/staff/staff.entity.ts[m
[1m+++ b/src/modules/staff/staff.entity.ts[m
[36m@@ -16,7 +16,8 @@[m [mexport class Staff {[m
   @Column()[m
   venueId: number;[m
 [m
[31m-  @ManyToOne(() => Venue, (venue) => venue.staff, { onDelete: 'CASCADE' })[m
[32m+[m[32m  @ManyToOne(() => Venue, { onDelete: 'CASCADE' })[m
[32m+[m
   venue: Venue;[m
 [m
   @Column()[m
[1mdiff --git a/src/modules/users/users.service.ts b/src/modules/users/users.service.ts[m
[1mindex 634a8b7..b038d5a 100644[m
[1m--- a/src/modules/users/users.service.ts[m
[1m+++ b/src/modules/users/users.service.ts[m
[36m@@ -71,14 +71,16 @@[m [mexport class UsersService {[m
       return this.usersRepository.save(existing);[m
     }[m
 [m
[31m-    const newUser = this.usersRepository.create({[m
[31m-      email,[m
[31m-      passwordHash,[m
[31m-      displayName,[m
[31m-      // NOTE: this line requires User.role to exist[m
[31m-      role,[m
[31m-    } as any);[m
[32m+[m[32m   const newUser = this.usersRepository.create({[m
[32m+[m[32m  email,[m
[32m+[m[32m  passwordHash,[m
[32m+[m[32m  displayName,[m
[32m+[m[32m  // NOTE: this line requires User.role to exist[m
[32m+[m[32m  role,[m
[32m+[m[32m} as any);[m
[32m+[m
[32m+[m[32m// âœ… force single-entity overload[m
[32m+[m[32mreturn this.usersRepository.save(newUser as any);[m
 [m
[31m-    return this.usersRepository.save(newUser);[m
   }[m
 }[m
[1mdiff --git a/src/wallet/wallet.service.ts b/src/wallet/wallet.service.ts[m
[1mindex b0bbcb0..43b6aa2 100644[m
[1m--- a/src/wallet/wallet.service.ts[m
[1m+++ b/src/wallet/wallet.service.ts[m
[36m@@ -5,7 +5,8 @@[m [mimport {[m
   NotFoundException,[m
 } from '@nestjs/common';[m
 import { InjectRepository } from '@nestjs/typeorm';[m
[31m-import { Repository, DataSource } from 'typeorm';[m
[32m+[m[32mimport { Repository, DataSource, DeepPartial } from 'typeorm';[m
[32m+[m
 [m
 import { Wallet } from './wallet.entity';[m
 import { CashoutRequest, CashoutStatus } from './cashout-request.entity';[m
[36m@@ -699,7 +700,6 @@[m [mexport class WalletService {[m
         throw new BadRequestException('Invalid cashout amount');[m
       }[m
 [m
[31m-      // Pull all cashout-type ledger rows for this wallet and filter by metadata.cashoutId[m
       const all = await txRepo.find({[m
         where: {[m
           walletId: cashout.walletId as any,[m
[36m@@ -722,12 +722,10 @@[m [mexport class WalletService {[m
         0,[m
       );[m
 [m
[31m-      // Idempotent: already fixed (net zero) OR already has refund-only sum=+amount[m
       if (sum === 0 || sum === amount) {[m
         return cashout;[m
       }[m
 [m
[31m-      // Only repair the exact broken pattern: debit-only == -amount[m
       if (sum !== -amount) {[m
         throw new BadRequestException([m
           `Not a debit-only FAILED cashout (sum=${sum}, amount=${amount})`,[m
[36m@@ -746,7 +744,7 @@[m [mexport class WalletService {[m
         txRepo.create({[m
           walletId: wallet.id,[m
           type: 'cashout',[m
[31m-          amountCents: amount, // +amount refund[m
[32m+[m[32m          amountCents: amount,[m
           metadata: {[m
             reason: 'cashout_repair_refund',[m
             cashoutId: cashout.id,[m
[36m@@ -762,7 +760,6 @@[m [mexport class WalletService {[m
       return updated;[m
     });[m
 [m
[31m-    // emit after txn (consistent with your other flows)[m
     const wallet = await this.walletRepo.findOne({[m
       where: { id: saved.walletId },[m
     });[m
[36m@@ -782,7 +779,7 @@[m [mexport class WalletService {[m
     const savedCashout = await this.dataSource.transaction(async (manager) => {[m
       const cashoutRepo = manager.getRepository(CashoutRequest);[m
       const walletRepo = manager.getRepository(Wallet);[m
[31m-      const txRepo = manager.getRepository(WalletTransaction); // âœ… ADD (ledger repo inside txn)[m
[32m+[m[32m      const txRepo = manager.getRepository(WalletTransaction);[m
 [m
       const cashout = await cashoutRepo.findOne({[m
         where: { id: cashoutId },[m
[36m@@ -850,12 +847,12 @@[m [mexport class WalletService {[m
     userId: number,[m
     cashoutId: number,[m
   ): Promise<CashoutRequest> {[m
[31m-    return this.dataSource.transaction(async (manager) => {[m
[32m+[m[32m    // âœ… ADDED: generic return type to stop TS inferring CashoutRequest | CashoutRequest[][m
[32m+[m[32m    return this.dataSource.transaction<CashoutRequest>(async (manager) => {[m
       const cashoutRepo = manager.getRepository(CashoutRequest);[m
       const walletRepo = manager.getRepository(Wallet);[m
       const txRepo = manager.getRepository(WalletTransaction);[m
 [m
[31m-      // 1) Load the FAILED cashout (NO LOCKS - SQLite safe)[m
       const original = await cashoutRepo.findOne({[m
         where: { id: cashoutId },[m
         relations: ['wallet'],[m
[36m@@ -874,9 +871,6 @@[m [mexport class WalletService {[m
         throw new BadRequestException('Invalid cashout amount on original');[m
       }[m
 [m
[31m-      // 2) IDEMPOTENCY WITHOUT LOCKS:[m
[31m-      // If we already created a retry PENDING, return it.[m
[31m-      // This requires CashoutRequest.retryOfCashoutId column to exist.[m
       const existingPending = await cashoutRepo.findOne({[m
         where: {[m
           retryOfCashoutId: original.id as any,[m
[36m@@ -886,7 +880,6 @@[m [mexport class WalletService {[m
 [m
       if (existingPending) return existingPending;[m
 [m
[31m-      // 3) Wallet debit[m
       const wallet = await walletRepo.findOne({[m
         where: { id: original.walletId },[m
       });[m
[36m@@ -900,19 +893,20 @@[m [mexport class WalletService {[m
         Number(wallet.cashoutAvailableCents) - amount;[m
       await walletRepo.save(wallet);[m
 [m
[31m-      // 4) Create the retry cashout[m
[31m-      const retry = await cashoutRepo.save([m
[31m-        cashoutRepo.create({[m
[31m-          walletId: wallet.id,[m
[31m-          amountCents: amount,[m
[31m-          status: 'PENDING',[m
[31m-          failureReason: null,[m
[31m-          destinationLast4: original.destinationLast4 ?? null,[m
[31m-          retryOfCashoutId: original.id as any,[m
[31m-        } as any),[m
[31m-      );[m
[32m+[m